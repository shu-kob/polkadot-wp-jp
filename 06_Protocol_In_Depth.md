6. Protocol in Depth
6. プロトコルの詳細
プロトコルは大きく分けて、コンセンサスメカニズム、パラチェーンインターフェース、チェーン間トランザクションルーティングの3つの部分に分けられる。

6.1. Relay-chain Operation.
6.1. リレーチェーンの運用
リレーチェーンは、アドレスとアカウント情報、主に残高と（リプレイを防ぐための）取引カウンターをマッピングしたステートベースであるという点で、イーサリアムと大差ないチェーンになると思われます。アカウントをここに置くことで、どのIDがどの程度のステークをシステムに所有しているかという会計処理を行うという1つの目的が達成されます。(特定の保有者がシステム全体のセキュリティに責任を持つ量を表す手段として、これらのステークアカウントは必然的に何らかの経済的価値を内包することになります。しかし、このような価値を現実世界の商品やサービスと交換する目的で使用する意図はないので、それに応じて、トークンを通貨に例えてはならず、そのようにリレーチェーンはアプリケーションに関するニヒリズム(虚無主義)の哲学を保持することを理解する必要があります。)

- しかし、注目すべき相違点がある。それは、トランザクションを通じてコントラクトを展開できないこと、リレーチェーン上のアプリケーション機能を避けたいことから、コントラクトの公開展開に対応しないことである。

- 計算資源の使用量（ガス）は計上されない。公開されるのは固定機能だけなので、ガス計上の根拠はもはや成り立たない。そのため、すべてのケースで定額料金が適用され、動的なコード実行が必要な場合でも、より高いパフォーマンスと、よりシンプルなトランザクション形式が可能になります。

- 上場契約では、自動実行とネットワークメッセージの出力を可能にする特別な機能がサポートされています。

リレーチェーンがVMを持ち、EVMをベースにしている場合、最大限の単純性を確保するために多くの変更が加えられる。おそらく、コンセンサス契約、バリデータ契約、パラシェーン契約など、プラットフォーム固有の義務を管理できるように、（イーサリアムのアドレス1〜4のような）多くの契約が組み込まれているはずです。

EVMでない場合、WebAssembly[2]（wasm）バックエンドが最も可能性の高い選択肢です。この場合、全体構造は似ていますが、EVMの未熟で限られた言語ではなく、Wasmが汎用言語のターゲットとして有効であるため、組み込みの契約は不要になるでしょう。

例えば、Serenityシリーズで提案されたように、同一ブロック内で競合しないトランザクションの並列実行を可能にするトランザクション受信形式の簡素化など、現在のEthereumプロトコルからの逸脱は十分に考えられる。

Serenityのような「純粋な」チェーンがリレーチェーンとして展開され、特定のコントラクトがチェーンのプロトコルの基本部分ではなく、ステーキングトークンの残高などを管理できるようになる可能性は低いですが、あります。現在のところ、私たちはこの方法が、開発に伴う複雑さと不確実性に見合うだけの十分なプロトコルの簡素化をもたらすとは思えません。

コンセンサスメカニズム、バリデータセット、検証メカニズム、パラチェインを管理するために必要な小さな機能の断片がいくつか存在する。これらはモノリシックなプロトコルでまとめて実装することができる。しかし、モジュール性を高める理由から、我々はこれらをリレーチェーンの「契約」と表現する。これは、リレーチェーンの合意機構によって管理されるオブジェクト（オブジェクト指向プログラミングの意味で）であることを意味するが、必ずしもEVMのようなオペコードでプログラムとして定義されているわけではなく、アカウントシステムを通じて個別にアドレス指定できるわけでもないと考えるべきだろう。

6.2. Staking Contract.
6.2. ステーキング契約。
この契約はバリデータセットを管理する。管理するのは以下の通り。

- どのアカウントが現在バリデータであるか。

- 短期間でバリデーターになることが可能なアカウント。

- どのアカウントがバリデーターに指名するステークを置いたか。

- ステーク量、許容ペイアウト率、アドレス、短期(セッション)IDなどの各プロパティ。

アカウントは、ボンドバリデータになる希望(およびその要件)を登録し、あるIDにノミネートを行い、 既存のボンドバリデータはこの状態から抜ける希望を登録することができる。また、バリデーションと正規化の仕組みそのものも含まれる。

6.2.1. Stake-token Liquidity.
6.2.1. ステーク・トークンの流動性

これはネットワークの安全性を杭打ちトークンの全体的な「時価総額」に直接結びつけるため、一般的にはネットワーク保守作業内でできるだけ多くの杭打ちトークンを持つことが望ましいとされる。これは、通貨を膨張させ、その収益をバリデーターとして参加した人に渡すことで容易に動機付けることができます。しかし、そうすることで問題が生じます。トークンが削減の罰を受けてステーキング契約にロックされた場合、価格発見を可能にするために、どのようにして相当部分を十分に流動的に保つことができるでしょうか。

これに対する1つの答えは、基礎となるステーク・トークンの上に交換可能なトークンを確保する、単純なデリバティブ契約を認めることです。これはトラストフリーな方法でアレンジすることが困難です。さらに、ユーロ圏の異なる国債がカンジブルでないのと同じ理由で、これらのデリバティブ・トークンは平等に扱えません。ユーロ圏の政府では、債務不履行が発生する可能性がある。バリデーターがステークしたトークンでは、バリデーターが悪意を持って行動し、処罰される可能性がある。

我々の信条に基づき、我々は最も単純な解決策を選択した。これは、ある割合（おそらく20%）のトークンが強制的に流動性を保つことを意味します。これはセキュリティの観点からは不完全ですが、ネットワークのセキュリティに根本的な違いをもたらすことはないでしょう。100%ステークする「完璧なケース」に比べれば、債券没収による賠償金の80%はまだ可能でしょう。

ステークされたトークンと流動的なトークンの比率は、リバースオークションメカニズムによって非常に簡単にターゲットにすることができます。基本的に、バリデーターになることに関心のあるトークン保有者は、参加するために必要な最低限のペイアウト率を明記したオファーを、ステーク契約に対してそれぞれポストする。各セッションの開始時に（セッションは定期的に、おそらく1時間に1回）、各バリデーター候補の賭け金とペイアウト率に応じて、バリデーター枠が埋まっていく。このための一つの可能なアルゴリズムは、対象となる賭け金の合計をスロット数で割った額より高くはなく、その額の半分を下限とする賭け金を示す、最も低い申し出の者を選ぶというものである。スロットが埋まらない場合は、下限を満たすために何らかの要因で繰り返し減少させることができます。

6.2.2. Nominating.
6.2.2. 指名する。
アクティブなバリデータに対して、信頼に基づきステークトークンを指名し、バリデータ の責務を与えることが可能である。ノミネートは、承認投票システムを通じて行われる。各ノミネーターは、ステーキングコントラクトに、自分の債券を預けるバリデーターを1人以上指定することができます。

各セッションにおいて、ノミネーターの債券は、1人以上のバリデーターに分散して預けられる。分散アルゴリズムは、債券の総額が等しくなるようにバリデーターを最適化する。ノミネータの債券はバリデータの責任下に置かれ、それに応じて利子を得たり、 罰を減らしたりする。

6.2.3. Bond Confiscation/Burning.
6.2.3. 保証金の没収/焼却

ある種のバリデーターの行動は、罰則としてその保証金を減額することになる。保証金が許容最小値より少なくなった場合、そのセッションは早々に終了し、次のセッションが開始される。処罰の対象となるバリデーターの不品行には、以下のようなものがあります。

- パラチェーンブロックの有効性についてコンセンサスを得ることができないパラチェーングループの一員であること。

- 無効なパラチェーンブロックの有効性について、積極的に署名すること。

- 以前に利用可能として投票されたイグレスペイロードを供給できないこと。

- コンセンサスプロセス中の非活動。

- 競合するフォークのリレーチェーンブロックを有効化すること。

不正行為の中には、ネットワークの完全性を脅かすものがあり（無効なパラチェーンブロックに署名したり、フォークの複数の側を検証したり）、その結果、絆の完全な縮小によって効果的に追放される。その他の、それほど深刻ではないケース（コンセンサスプロセスにおける非活動など）や、責任を正確に負えないケース（非効率なグループの一員であること）では、代わりに保証金の一部が罰金として支払われることがあります。後者の場合、悪意のあるノードが共謀して損害を受けた善意のノードよりも実質的に多くの損失を被ることを保証するために、サブグループの解約とうまく連動する。

場合によっては(マルチフォーク検証や無効なサブブロックへの署名など)、各パ ラチェーンブロックを常に検証するのは大変な作業なので、バリデータは互いの 不正行為を容易に検出できない。そこで、検証プロセスの外部にいる関係者の協力を得て、そのような不正行為を 検証し報告する必要がある。報告者には報酬が与えられる。「漁夫の利」という言葉は、このような報酬が得られないことに由来する。

このようなケースは一般的に非常に深刻なので、報酬は没収された債券から簡単に支払われることを想定しています。一般に我々は、全面的な再配分を試みるよりも、焼却（つまり無に帰すこと）と再配分のバランスをとることを好む。これは、トークンの全体的な価値を高める効果があり、発見に関与した特定の当事者ではなく、ネットワーク全般をある程度補償することになります。これは主に安全機構として機能します。多額のトークンが単一のターゲットに付与されると、極端で深刻な行動の誘因になる可能性があります。

一般に、報酬はネットワークにとって検証の価値を高めるのに十分な大きさであることが重要 であるが、不運な検証者に不品行を強いるために、十分な資金と組織力を備えた「産業レベル」 の犯罪的ハッキング攻撃を行うコストを相殺できるほど大きくないことが必要である。

このように、不正を行い、報奨金を得るために自ら報告するという逆インセンティブが生じないよう、請求額は一般に不正を行ったバリデータの直接の保証額より大きくならないようにする必要がある。これは、バリデータになるための直接の保証の最低条件を明示的に定めるか、または 推薦者を教育して、保証がほとんどないバリデータには良い行いをするインセンティブがあまりないことを暗黙的に教えることで、防ぐことができるだろう。

6.3. Parachain Registry.
6.3. パラチェーンレジストリ。

各パラチェーンはこのレジストリに定義されています。これは比較的単純なデータベースのような構造で、各チェーンに関する静的情報と動的情報の両方を保持します。

静的情報には、チェーンインデックス(単純な整数)、検証プロトコルID、パラチェインの異なるクラスを区別する手段、有効な候補を提示することを委託されたバリデータが正しい検証アルゴリズムを実行できるようにするためのもの、などがある。最初の概念実証では、新しい検証アルゴリズムをクライアント自体に組み込むことに焦点を当て、チェーン のクラスが追加されるたびにプロトコルのハードフォークが必要になります。しかし最終的には、検証アルゴリズムを厳密かつ効率的に指定することで、クライアントがハードフォークせずに新しいパラチェインを効果的に扱うことができるようになるかもしれません。そのための1つの方法は、WebAssemblyのような確立された、ネイティブにコンパイルされた、プラットフォームに中立な言語でパラチェーン検証アルゴリズムを指定することでしょう。これが本当に実現可能かどうかを判断するには、さらなる研究が必要ですが、もしそうなら、ハードフォークを永久に追放するという大きな利点をもたらすかもしれません。

動的な情報は、パラシェインのイングレスキュー(セクション6.6で説明)のような グローバルな合意を持たなければならないトランザクションルーチングシステムのアスペクトを 含む。

これは内部で管理できますが、より一般的なガバナンスコンポーネントのもとでの再利用を容易にするために、外部のレフェレンダム契約に配置される可能性が高いでしょう。追加チェーンの登録や、その他のあまり正式でないシステムのアップグレードのための投票要件（例：必要な定足数、必要な過半数）に対するパラメータは、「マスター憲法」で定められるが、少なくとも当初は、かなり伝統的な経路をたどることになるだろう。正確な定式化は本研究の範囲外であるが、例えば、システム全体の出資者の3分の1以上が賛成票を投じ、3分の2の賛成で可決することが、賢明な出発点となり得るだろう。

追加的な操作として、パラチェーンの停止と削除があります。停止はできれば起こりえないことですが、パラチェンの検証システムに何らかの難解な問題があった場合の安全策となるように設計されています。この措置が必要となる最も明白な例は、実装の違いによってバリデータが有効性またはブロックについて合意できない場合です。バリデータは複数のクライアント実装を使用することを推奨され、債券没収の前に このような問題を発見することができるようになる。

一時停止は緊急措置であるため、国民投票ではなく、動的検証者の投票によって行われる。再導入は、バリデータまたは国民投票のいずれによっても可能である。

パラチェーンを完全に削除する場合は、レファレンダムの後に、独立したチェーンとして、あるいは他のコンセンサスシステムの一部として秩序ある移行ができるよう、かなりの猶予期間が必要である。この猶予期間は数ヶ月のオーダーになると思われ、パラチェーン登録簿にチェーンごとに設定され、パラチェーンの必要性に応じて異なる猶予期間を享受できるようになると思われます。

6.4. Sealing Relay Blocks.
6.4. リレーブロックのシーリング。

封印とは、本質的には正規化のプロセスを指します。つまり、オリジナルを基本的に単一で意味のあるものにマッピングする基本的なデータ変換です。PoWチェーンでは、シーリングは事実上マイニングと同義です。この場合、特定のリレーチェーンブロックとそれが表すパラチェーンブロックの有効性、可用性、正規性に関して、バリデータから署名されたステートメントを収集することが必要です。

BFTコンセンサスアルゴリズムの基礎となる仕組みは、今回のテーマからは外れています。その代わりに、コンセンサスを生み出すステートマシンを想定したプリミティブを使用して説明することにします。最終的には、Tangaora [9]（Raft[16]のBFT版）、Tendermint [11]、HoneyBadgerBFT [14]などの有望なBFT合意アルゴリズムに触発されると予想している。このアルゴリズムは、複数のパラチェーンについて並行して合意に達する必要があるため、通常のブロックチェーンの合意形成メカニズムとは異なります。我々は、いったんコンセンサスが成立すれば、そのコンセンサスを参加者の誰もが提供できる反論の余地のない証明に記録できると仮定している。また、このプロトコルにおける不正行為は、不正行為を行った参加者を含む小さなグループに限定することで、処罰を与える際の巻き添えを最小限に抑えられると想定しています。

(Tendermint BFTやオリジナルのSlasherなど、既存のPoSベースのBFTコンセンサス方式は、これらの主張を満たしています。)

この証明は署名されたステートメントという形で、リレーチェーンブロックのヘッダーに、リレーチェーンのステートリールートやトランザクショントリールートをはじめとする他のフィールドと一緒に格納されます。

封印処理は、リレーチェーンのブロックとリレーコンテンツの一部を構成するパラチェーンブロックの両方に対応する単一の合意形成メカニズムの下で行われます。パラチェーンは、サブグループによって個別に「コミット」され、後で照合されることはありません。この結果、リレーチェーンの処理はより複雑になりますが、システム全体のコンセンサスを一段階で完了させることができ、レイテンシーを最小限に抑え、以下のルーティング処理に役立つ非常に複雑なデータ可用性要件に対応できるようになります。

各参加者のコンセンサスマシンの状態は、単純な（2次元の）表としてモデル化することができる。各参加者（バリデータ）は、各パラチェーンブロック候補とリレーチェーンブロック候補に関する、他の参加者からの署名付きステートメント（「投票」）の形で、一連の情報を持っている。この情報は次の2つのデータである。

可用性: このバリデータは、このブロックからのイグレス・トランザクション・ポスト情報を 持っており、次のブロックのパラチェーン候補を適切に検証できるか。バリデータは1(既知)または0(未知)のいずれかに投票することができる。一旦1に投票すると、彼らはこのプロセスの残りの間、同じように投票することを約束する。これを無視した後の投票は処罰の対象となる。

有効性: パラチェーンブロックは有効か、また外部から参照されるデータ(例：トランザクション)はすべて利用可能か。これは、投票対象のパラチェーンに割り当てられたバリデーターにのみ関係する。彼らは1(有効)、-1(無効)、0(未知)のいずれかに投票することができる。一旦0以外の票を投じると、プロセスの残りの期間、この方法で投票することを約束する。
一旦0以外の票を投じると、その後のプロセスではこの方法で投票することを約束する。これを無視した投票が行われた場合には、処罰の対象となる。

すべての検証者は投票を提出しなければならない。投票は、上記の規則に従って再提出してもよい。コンセンサスの進行は、各パラチャインに対する複数の標準的なBFTコンセンサスアルゴリズムが並行して行われるものとしてモデル化することができる。これらは、比較的少数の悪意ある行為者が単一のパラチャングループに集中することによって妨害される可能性があるため、全体のコンセンサスは、デッドロックからの最悪のシナリオを、単に1つまたは複数の無効なパラチャンブロック（および責任者へのラウンド処罰）だけに制限し、バックストップを確立するために存在します。

個々のブロックの有効性に関する基本的なルール（正規のリレーから参照される唯一のパラチェーン候補となることについて、検証者の全体的な集合がコンセンサスを得ることができる）。

- その有効者のうち、少なくとも3分の2が賛成票を投じ、反対票は投じないこと。

- 3分の1以上のバリデータが、退出キュー情報の有効性について肯定的な投票を行っていること。

有効性について、肯定的な投票が少なくとも1件、否定的な投票が少なくとも1件 あった場合、例外状態が発生し、バリデータ全体の投票により、悪意ある者の存在 や偶発的なフォークの有無を判断しなければならない。有効・無効の他に、第3の種類の投票が認められている。これは両方に投票することと等しく、ノードが相反する意見を持っていることを意味する。これはノードの所有者が同意しない複数の実装を実行しているためであり、プロトコルに曖昧さがある可能性を示している。

全バリデータからの投票を数えた後、負けた意見が勝った意見の票の少なくともいくらかの小さな割合(パラメータ化される; せいぜい半分、おそらくかなり少ない)を持っていれば、それは偶然のパラチャンフォークであると仮定し、パラチャンは合意プロセスから自動的に停止される。そうでなければ、悪意ある行為とみなし、反対意見に投票していた少数派を罰する。

結論は正統性を証明する署名の集合である。その後、リレーチェーンブロックを封印し、次のブロックを封印する処理を開始することができる。

6.5. Improvements for Sealing Relay Blocks.
6.5. リレーブロックの封印の改良。

この封印方式はシステムの動作を強力に保証するが、各パラチャインの鍵情報は 全バリデータの3分の1以上が利用可能であることを保証しなければならないため、 特にスケールアウトがうまくいかない。つまり、チェーンが増えれば増えるほど、各バリデーターの責任範囲は大きくなる。

オープンコンセンサスネットワークにおけるデータの可用性は本質的に未解決の問題であるが、バリデータ・ノードにかかるオーバーヘッドを軽減する方法はある。その一つは、バリデータはデータの可用性に責任を持たなければならないが、実際にデータを保存、通信、複製する必要はないことを認識することである。データをコンパイルするコレーターに関連する（あるいは全く同じ）二次的なデータサイロ が、バリデータの利子や収入の一部を支払って、可用性を保証するタスクを管理することが できるかもしれない。

しかし、これによって中間的なスケーラビリティは確保できるかもしれないが、根本的な問 題は解決しない。一般に、チェーンを増やすとバリデータを追加する必要があるため、継続的な ネットワークリソース消費（特に帯域幅）はチェーンの二乗とともに増加し、長期的には耐えられない 性質となる。

結局のところ、コンセンサスネットワークが安全であるとみなされるためには、必要な帯域幅はバリデータの総量×入力情報の総量のオーダーになるという基本的な制限に頭をぶつけ続けることになりそうです。これは、信頼されていないネットワークでは、データストレージのタスクを多くのノードに適切に分散させることができないためで、処理という極めて分散可能なタスクとは切り離されています。

6.5.1. Introducing Latency.
6.5.1. レイテンシーの導入

このルールを緩和する一つの方法は、即時性の概念を緩和することである。33%+1%のバリデータが、即時ではなく最終的にのみ利用可能かどうかを 判断するよう求めることで、指数関数的なデータ伝搬をうまく利用し、 データ交換のピークを均等にすることができる。合理的な等式は(証明されていないが)次のようなものであろう。

(1) latency = participants × chains

現在のモデルでは、処理が分散されるように、システムの規模は連鎖の数に比例する。各連鎖は少なくとも1人の検証者を必要とし、可用性の証明は検証者の一定の割合に固定されるので、参加者は同様に連鎖の数に比例して増加する。結局、以下のようになる。

(2) latency = size^2
つまり、システムが成長するにつれて、必要な帯域幅と、ネットワーク上で可用性を知るまでの待ち時間（これは、最終的に到達するまでのブロック数としても特徴づけられる）が、その2乗で増加するということである。これはかなりの成長要因であり、顕著な障害となることが判明し、いくつかの「Polkadotes」を階層化し、リレーチェーンのツリーを介して投稿を多段ルーティングするような「非フラット」パラダイムを強いられるかもしれません。

6.5.2. Public Participation.
6.5.2. 一般市民の参加

もう一つの可能な方向は、マイクロクレームシステムを通じて、このプロセスへの一般市民の参加を得ることである。fishermanと同じように、利用可能性を主張する検証者を取り締まる外部機関を設けることも可能である。彼らの仕事は、そのような利用可能性を示すことができないと思われる人を見つけることである。そうすることで、彼らは他のバリデータに対して苦情を申し立てることができる。シビルアタックを軽減するために、PoWまたはステイクドボンドを使用することができる。

6.5.3. Availability Guarantors.
6.5.3. アベイラビリティ(可用性)保証人

最終的な方法として、2つ目の保証付きバリデータを "可用性保証者 "として指名することが考えられる。これらのバリデータは通常のバリデータと同様に結合され、 同じバリデータから選択することもできる(その場合、少なくともセッションごとに 長期間にわたって選択されることになる)。通常のバリデータと異なり、パラチェーン間の切り替えは行わず、1つのグループを形成し、 すべての重要なチェーン間データが利用可能であることを証明する。

これには、参加者とチェーンの間の等価性を緩和する利点がある。基本的に、チェーンは（元のチェーン検証者セットとともに）成長できるが、参加者、特に データ利用可能性証言に参加する者は、少なくとも線形でなく一定である可能性がある。

6.5.4. Collator Preferences.
6.5.4. コレーターのプリファレンス

このシステムの重要な側面の1つは、任意のパラチェーン内のブロックを作成するコレーターの健全な選択があることを保証することです。もし単一のコレーターがパラシェーンを支配していたら、外部データの利用可能性の欠如が目立たなくなるため、いくつかの攻撃がより実行しやすくなる。

1つのオプションは、さまざまなコレーターを支持するために、擬似ランダムなメカニズムで人工的にパラチャンブロックの重み付けをすることです。まず、コンセンサスメカニズムの一部として、バリデータが "重い "と判断したパラチャンブロック候補を支持することを要求する。同様に、バリデータが最も重いブロックを提案するようにインセンティブを与えなければならない。これは、報酬の一部を候補の重さに比例させることで実現できる。

照合者が自分の候補がコンセンサスの勝利候補として選ばれる妥当で公平な機会を与えられるように、パラチャンブロック候補の特定の重みを、各照合者に関連したランダム関数で決定するようにする。例えば、照合人のアドレスと、ブロックが作成される時点に近いところで決定される暗号的に安全な疑似乱数との間のXOR距離尺度をとります（想定上の「当たり券」）。これにより、各コレーター（より具体的には各コレーターのアドレス）は、自分の候補ブロックが他のすべてのブロックに「勝つ」ランダムなチャンスを効果的に得ることができます。

1人の照合者が勝ち組チケットに近いアドレスを「採掘」して、各ブロックのお気に入りになるというシビル攻撃を軽減するために、照合者のアドレスに何らかの慣性を持たせることになります。これは、そのアドレスに基準額の資金を持つことを要求するのと同じくらい簡単なことかもしれません。よりエレガントなアプローチとしては、当選チケットへの近さを、当該住所に駐車されている資金の額で重み付けすることでしょう。まだモデル化はされていませんが、このメカニズムにより、非常に小さなステークホルダーでも照合者として貢献できる可能性は十分にあります。

6.5.5. Overweight Blocks.
6.5.5. 過重なブロック

バリデータセットが危険にさらされた場合、有効ではあるが、実行と検証に膨大な 時間を要するブロックを作成し、提案する可能性がある。これは問題である。なぜなら、バリデータ・グループは、例えば大きな素数の因数分解など、 ショートカットを可能にする特定の情報が既に知られていない限り、実行に非常に長い 時間を要するブロックを合理的に作成することができるからである。もし一人の照合者がその情報を知っていれば、他の照合者が古いブロックの処理に追われている間、自分の候補を受理してもらうのに明らかに有利になる。我々はこのようなブロックをオーバーウェイトと呼ぶ。

このようなブロックを提出し検証するバリデータに対する保護は、大部分が無効なブロックに対するものと同じであるが、さらに注意点がある。ブロックの実行にかかった時間（つまりオーバーウェイトであるかどうか）は主観的であるので、不正行為に関する投票の最終結果は、基本的に3つの陣営に分かれる。この場合、3分の2以上の人が、ある制限(たとえば、ブロック間の許容総時間の50%)内でブロックを実行できると宣言します。もうひとつは、そのブロックが間違いなくオーバーウェイトであるということで、これは3分の2以上が、そのブロックを制限時間内に実行できないと宣言している場合です。最後の可能性は、バリデータ間の意見がほぼ等しい場合である。この場合、我々は相応の罰則を選択することができる。

バリデータがいつオーバーウエイトのブロックを提案するかを予測できるようにするために、バリデータは各ブロックのパフォーマンスに関する情報を公開することを義務づけるのが賢明であろう。十分な期間にわたって、バリデータは自分の処理速度を、審査する仲間との比較でプロファイリングすることができるはずである。

6.5.6. Collator Insurance.
6.5.6. コレーターの保険

PoWネットワークとは異なり、コレーターのブロックの有効性を確認するには、 そのブロック内のトランザクションを実際に実行しなければならない。悪意のあるコレーターが無効または過重なブロックをバリデータに送り、バリデータを悲しませ (リソースを浪費させ)、潜在的に大きな機会損失を与える可能性がある。

これを軽減するために、我々はバリデータ側の簡単な戦略を提案する。第一に、バリデータに送信されるパラチェーンブロック候補は、資金を持つリレーチェーン アカウントから署名されていなければならない。次に、そのような候補は、口座の資金量（上限あり）、コレーターが過去に提案したブロックの数（過去の処罰は言うまでもない）、および前述した当選チケットへの近接度の組み合わせ（たとえば乗算）によって優先順位が付けられるべきである。この上限は、バリデータが無効なブロックを送信した場合に支払われる懲罰的賠償金と同じであるべきである。

コレーターが無効または過重なブロック候補をバリデータに送信することを抑制するため、 バリデータは次のブロックに、不正行為を主張する違反ブロックを含む取引を置き、不正行為を したコレーターの口座の資金の一部または全部を、被害を受けたバリデータに転送することが できる。この種の取引は、コレーターが処罰前に資金を持ち出すことができないように、 他の取引より優先される。損害賠償として送金される金額は、まだモデル化されていない動的なパラメータであるが、 悲劇の度合いを反映して、バリデータのブロック報酬の割合となる可能性がある。悪意のあるバリデータがコレーターの資金を恣意的に没収するのを防ぐため、コレーターは、少額の保証金を支払う代わりに、ランダムに選ばれたバリデータの陪審員に、バリデータの判断を訴えることができる。陪審員がバリデータに有利な判決を下した場合、保証金は陪審員によって消費される。そうでない場合、保証金は返還され、バリデータは罰金を科される(バリデータはより高い地位にあるため、罰金はかなり高額になると思われる)。

6.6. Interchain Transaction Routing.

6.6. インターチェーントランザクションルーチング

チェーン間トランザクションのルーティングは、リレーチェーンとそのバリデータの 不可欠な保守作業の1つである。これは、投稿されたトランザクション(しばしば単に「投稿」と短縮される)が、あるソースパラチェーンから望ましい出力であるところから、他のデスティネーションパラチェーンの信頼要件なしの非交渉可能な入力となる方法を管理するロジックである。

私たちは上記の表現を慎重に選びました。特に、このポストを明示的に承認するために、ソースパラチェーンでのトランザクションがあったことを要求しているわけではありません。私たちがこのモデルに課す唯一の制約は、パラチェーンがブロック処理の全体的な出力の一部としてパッケージ化された、ブロックの実行結果であるポストを提供しなければならないということです。

これらのポストはいくつかのFIFOキューとして構成され、リストの数はルーティングベースとして知られ、約16になることがあります。注目すべきは、この数が、マルチフェーズ・ルーティングに頼ることなくサポートできるパラチェーンの数であることです。当初、Polkadotはこのような直接ルーティングをサポートしますが、最初のパラチェーンセットをはるかに超えてスケールアウトする手段として、可能なマルチフェーズルーティングプロセス（「ハイパールーティング」）の概要を説明します。

すべての参加者が次の2ブロックn, n + 1のサブグループ化を知っていると仮定する。要約すると、ルーティングシステムは以下のような段階を踏む。

- CollatorS: V alidators[n][S]のメンバーに連絡する。

- CollatorS。FOR EACH Subgroup s: V alidators[n][s]の少なくとも1つのメンバーが接触していることを確認する。

- CollatorS: FOR EACH subgroup s: egress[n - 1][s][S] が利用可能であると仮定（最後のブロックから 'S' へのすべての着信ポストデータ）。

- CollatorS: S のブロック候補 b を構成する: (b.header, b.ext, b.proof, b.receipt, b.egress)

- CollatorS: 証明情報 proof[S] = (b.header, b.ext, b.proof, b.receipt) を V alidators[n][S] に送信する．

- CollatorS: 外部取引データ b.ext を他の Collator や Validator が利用できるようにする。

- CollatorS: FOR EACH サブグループ s: V alidators[n + 1][s] ： 次のブロックの受信サブグループのメンバーに、退出情報 egress[n][S][s] = (b.header, b.receipt, b.egress[s]) を送る。

- ValidatorV : 同一集合のメンバーを次のブロックに事前接続する: N = Chain[n + 1][V ]とし、Chain[n + 1][v] = N となるすべてのバリデータvを接続する。

- ValidatorV : このブロックのすべてのデータ入力を照合する。FOR EACH サブグループ s: egress[n - 1][s][Chain[n][V]] を取得し、他のバリデータ v から Chain[n][v] = Chain[n][V] となるようなデータを取得する。試行の証明のために、ランダムに選んだ他のバリデータを経由する可能性もある。

- ValidatorV : このブロックに対する証明の候補を受け入れる proof[Chain[n][V ]]。ブロックの有効性を投票する

- ValidatorV : 次のブロックのegressデータの候補を受け付ける。FOR EACH subgroup s, accept egress[n][s][N]. Vote block egress availability; Chain[n + 1][v] = Chain[n + 1][V ]となるように、興味のあるバリデータvに再公開する。

- ValidatorV : UNTIL CONSENSUSとする。

ここで、egress[n][from][to] は、ブロック番号 'n' のパラチャン 'from' からパラチェーン 'to' に向かう投稿のための現在のイグレスキュー情報である。Validators[n][s] はブロック番号 n のパラチャン s のバリデータの集合であり、逆に Chain[n][v] はブロック番号 n でバリデータ v が割り当てられたパラチェーンである。ブロック.egress[to] はあるパラチャンブロックからの投稿で、宛先パラチェーンが to である投稿の出入りキューである。

コレーターは自分のブロックが正規化されることに基づいて(取引)料金を徴収するので、 次のブロックの宛先ごとに、そのサブグループのメンバーに現在のブロックからの退出キューを通知することを保証するインセンティブがある。バリデータは(パラチェーン)ブロックに関する合意を形成することだけに インセンティブを与えられており、そのため、どのコレーターのブロックが 最終的に正規化されるかについてはほとんど気にしない。原理的には、バリデータはあるコレーターに忠誠を誓い、他のコレーターのブロックが 正統化される機会を減らすために共謀することができるが、パラチェーンのバリデータは ランダムに選択されるため、これを手配することは難しく、また合意形成を阻害する パラカインブロックの料金を減額することで対抗することができる。

6.6.1. External Data Availability.
6.6.1. 外部データの利用可能性。

パラチェーンの外部データが実際に利用可能であることを保証することは、ネットワーク全体に作業負荷を分散させることを目的とした分散型システムにおける長年の問題である。この問題の核心は、可用性の非対話的証明も非可用性の証明も不可能であるため、BFTシステムが外部データの可用性に依存する遷移を適切に検証するには、システムの最大数のビザンチンノード（プラス1）がそのデータが利用可能であると証明しなければならない、という可用性の問題である。

Polkadotのようにシステムを適切にスケールアウトするためには、このことが問題を引き起こす。もし一定の割合のバリデータがデータの可用性を証明しなければならず、バリデータはデータが利用可能であると主張する前に実際にデータを保存したいと 思うとしたら、システムの規模（したがってバリデータの数）に応じて必要となる帯域幅 やストレージの数が増加するという問題をどう回避するか？1つの可能な答えは、バリデータ(可用性保証者)を別に用意し、その順番をPolkadot全体のサイズに比例して増加させることである。これについては6.5.3節で説明した。

また、二次的なトリックもある。グループとしてのコレーターは、自分が選んだパラチェーンについてすべてのデータが利用可能であることを保証する本質的なインセンティブを持つ。なぜなら、データがなければ、取引手数料を徴収できるブロックをさらに作成することができないからである。照合人はまた、（パラチェーン・バリデータ・グループのランダムな性質により）様々なグループを形成し、そのメンバーであることは自明でなく、証明も容易である。したがって、最近の照合人（おそらく直近の数千ブロックの照合人）は、特定のパラチャンブロックの外部データの利用可能性について、少額の保証金でバリデータを発行することが許可されている。

バリデータは、証言した違反バリデータサブグループに連絡し、データを取得して照合者に返却するか、データがないことを証言して問題を拡大させ(データの提供を直接拒否することは 保障金没収の違反となるので、違反バリデータは単に接続を切断するだろう)、追加のバリデータに連絡して同じテストを実行しなければならない。後者の場合、コレーターのボンドは返却される。

このような利用不能の証言を行えるバリデータの定足数に達したら、それらを解放し、 不正を行ったサブグループを処罰し、ブロックを元に戻す。

6.6.2. Posts Routing.
6.6.2. ポストルーティング。

各パラチェーンヘッダーはegress-trie-rootを含む。これはrouting-baseビンを含むトライの ルートであり、各ビンはegressポストの連結されたリストである。特定のパラチェーンのブロックが特定の宛先パラチェーンに対する特定のイグレスキューを持っていたことを証明するために、パラチェーンバリデータ間でマークル証明が提供されることがある。

パラチェーンブロックの処理の最初に、当該ブロックに対する他の各パラチェーンのegressキューバウンドは、我々のブロックのingressキューにマージされます。どのパラチェーンブロックのペアにもえこひいきをしない決定論的な処理を実現するために、強い、おそらくCSPR(暗号安全擬似ランダム)の、サブブロックの順序付けを仮定しています。コレータは新しいキューを計算し、パラチェインのロジックにしたがって退出キューを排出します。

イングレスキューの内容は、パラチェーンブロックに明示的に書き込まれます。第一に、パラチェーンを他のパラチェーンから分離して、信頼できる形で同期させることができます。バリデータおよびコレータは、キューのデータを特別に取得することなく、次のブロックを処理することができます。

ブロック処理の終了時にパラシェーンの受信キューが閾値を超えている場合、リレーチェーン上で飽和とマークされ、それがクリアされるまで、それ以上のメッセージは配信されないかもしれない。Merkle証明は、パラチェーンブロックの証明において、照合器の動作の忠実性を示すために使用される。

6.6.3. Critique.
6.6.3. 講評

この基本的な仕組みに関連する小さな欠陥として、ポストボム攻撃がある。これは、すべてのパラチェーンが特定のパラチェーンに可能な限り最大量のポストを送信するものである。これはターゲットのingressキューを一度に縛るが、標準的なトランザクションDoS攻撃以上のダメージは与えられない。

うまく同期された悪意のないコレーターとバリデーターのセットで通常通り動作させると、N個のパラ チェーン、N×M個のバリデーター、パラチェーンあたりL個のコレーターについて、ブロックごとの総データ 経路を以下のように分解することができる。バリデータ M -1+L+L: パラチェーンセットの他のバリデータに対してM-1、 パラチェーンブロックの候補を提供する各コレーターに対してL、 前のブロックのegressペイロードを必要とする次のブロックの各コレーターに対して 2番目のLが必要である。(後者は、コレーターがそのようなデータを共有する可能性が高いため、実際には最悪の場合の動作に近い)。
を共有する可能性が高いため、後者の方がよりワーストケースに近い動作となる)。

コレータ。M+kN: Mは関連する各パラチャンブロックバリデータへの接続、kNは次のブロックの各パラ チャンバリデータグループのサブセット(および場合によっては優先コレーター)へのイグレス ペイロードのシードである。

このように、ノードあたりのデータパス経路は、システム全体の複雑さに応じて直線的に増加する。これは合理的ですが、システムが数百または数千のパラケインにスケールアップすると、より低い複雑さの成長率と引き換えに、いくつかの通信レイテンシが吸収されるかもしれません。この場合、ストレージバッファとレイテンシを導入する代償として、瞬時経路の数を減らすために、マルチフェーズルーティングアルゴリズムが使用されることがあります。

6.6.4. Hyper-cube Routing.
6.6.4. ハイパーキューブ・ルーティング

ハイパーキューブルーティングは、ほとんどが上述の基本的なルーティングメカニズムの拡張として構築できるメカニズムである。基本的に、パラチェーンやサブグループノードの数でノード接続性を成長させるのではなく、パラチェーンの対数でのみ成長させる。ポストが最終的に配送されるまでに、いくつかのパラチェーンのキューを経由することがあります。

ルーティング自体は決定論的で単純です。パラチェーンの総数ではなく、ルーティングベース（b）である。これはパラシェーンの数が変わると固定され、代わりにルーティング指数(e)が上げられる。このモデルでは、メッセージ量はO(b^e)で増加し、経路は一定、レイテンシ（配送に必要なブロック数）はO(e)となります。

経路のモデルはe次元の超立方体で、立方体の各辺にはb個の可能な位置があります。各ブロックは、1つの軸に沿ってメッセージをルーティングする。ラウンドロビン方式で軸を交互に配置することで、最悪でもeブロックの配送時間を保証しています。

パラシェーン処理の一部として、イングレスキューで見つかった外国行きのメッセージは、現在のブロック番号（したがってルーティング次元）が与えられると、適切なイグレスキューのビンに直ちにルーティングされます。このプロセスは、配信ルート上の各ホップに対して追加のデータ転送を必要とするが、これは、データペイロード配信の何らかの代替手段を使用し、ポストの完全なペイロードではなく、参照のみをポストトリに含めることによって軽減され得る問題自体である。

4つのパラチェーン、b＝2、e＝2を有するシステムに対するこのようなハイパーキューブルーティングの例は、以下のとおりである。
フェーズ0では、各メッセージMについて
- sub0: もしMdest∈{2, 3}ならsendTo(2) else keep
- sub1: もしMdest∈{2, 3}ならsendTo(3)else keep
- sub2: もしMdest∈{0, 1} ならば sendTo(0) else keep
- sub3: もしMdest∈{0, 1} なら sendTo(1) else keep
フェーズ1では、各メッセージMに対して
- sub0: もしMdest∈{1, 3} ならばsendTo(1) else keep
- sub1: もしMdest∈{0, 2} ならばsendTo(0) else keep
- sub2: もしMdest∈{1, 3} ならばsendTo(3) else keep
- sub3: もしMdest∈{0, 2} ならばsendTo(2) else keep

ここでの2次元は、宛先インデックスの最初の2ビットと考えるとわかりやすい。最初のブロックでは、高次のビットだけを使用する。2番目のブロックは低次のビットを扱います。両方が (任意の順番で) 起これば、ポストはルーティングされます。

6.6.5. Maximising Serendipity.
6.6.5. セレンディピティの最大化

基本提案の変更点として、c^2 - c個のバリデータを固定し、各サブグループにc-1個のバリデータ を配置する。各ブロックで、パラチャン間のバリデータの非構造的な再分割を行うのではなく、 各パラチャンサブグループで、各バリデータを次のブロックのユニークで異なるパラチェーンサブグループに割り当てることにする。これにより、任意の2ブロック間で、任意の2組のパラチェーンについて、 パラチェーンを入れ替えた2人のバリデータが存在するという不変性が得られる。これは可用性の絶対的な保証にはならないが(たとえ善良なバリデータであっても、 1人のバリデータがオフラインになることはある)、それでも一般的なケースを 最適化することは可能である。

このアプローチには複雑な点がないわけではない。パラシェーンを追加する場合、バリデータセットを再編成する必要がある。さらに、バリデータの数はパラシェーン数の2乗に比例するため、最初は非常に少ないが、やがて増えすぎ、50パラシェーン程度で手に負えなくなる。これらはいずれも根本的な問題ではない。最初のケースでは、バリデータセットの再編成はいずれにせよ定期的に行わなければならないものである。バリデータセットが小さすぎる場合、複数のバリデータが同じパラチェーンに割り当てられ、バリデータ全体の合計に整数倍の係数が適用される可能性がある。6.6.4で議論したハイパーキューブルーティングのような多相ルーチングメカニズムは、チェーン数が多い場合に大量のバリデータを必要とすることを 緩和するだろう。

6.7. Parachain Validation.
6.7. パラチェーン・バリデーション

バリデータの主な目的は、パラチェインのブロックが有効であることを、 結合されたアクターとして証言することである。これには、あらゆる状態遷移、 含まれるあらゆる外部トランザクション、待ち行列のあらゆる実行、および 終了待ち行列の最終状態が含まれるが、これに限定されない。処理自体はかなり単純である。バリデータが前のブロックを破棄すると、彼らは自由に次のラウンドのコンセンサスの ためのパラチャンブロック候補を提供する作業を開始することができる。

最初に、バリデータはパラカインコレーター(次を参照)またはその共同バリデータの 一つを通して、パラカインブロックの候補を見つける。パラチャンブロック候補のデータには、ブロックのヘッダー、前のブロックのヘッダー、含まれるあらゆる外部入力データ（イーサリアムとビットコインでは、このようなデータはトランザクションと呼ばれるが、原理的には任意の目的のために任意のデータ構造を含むことができる）、イグレスキューデータ、状態遷移有効性を証明する内部データ（イーサリアムでは各取引の実行に必要となる様々な状態/ストレージトライノードであると考えられる）、がある。実験によると、最近のイーサリアムブロックのこの完全なデータセットはせいぜい数百KiBである。

同時に、バリデータは前のブロックの遷移に関連する情報を取得しようとする。 最初は前のブロックのバリデータから、後にデータの可用性に署名した全バリデータから取得する。

バリデータはこのような候補ブロックを受け取ると、ローカルでその検証を行う。これはコンセンサスに敏感なソフトウェアモジュールであり、 Polkadotのどのような実装に対しても記述しなければならない(原理的には、 C言語のABIを持つライブラリにより、単一の「参照」実装を持つことで安全性を適切に低下させ、 一つのライブラリを実装間で共有することが可能である)。

このプロセスは前のブロックのヘッダーを取り、そのハッシュが記録されるべき最近合意されたリレーチェーンブロックを通してその身元を確認する。親ヘッダーの有効性が確認されると、特定のパラチェーンクラスの検証関数 が呼び出されるかもしれない。これは、いくつかのデータフィールド(だいたい先にあげたもの)を受け取り、ブロックの有効性を宣言する単純なブール値を返す単一の関数である。

このような検証関数の多くは、まず親ブロックから直接得られるヘッダーフィールドをチェックします (たとえば、親ハッシュや数値)。その後、取引や投稿を処理するために必要な内部データ構造を生成する。イーサリアムのようなチェーンでは、トランザクションの完全な実行に必要なノードをトリアデータベースに登録することになる。他の種類のチェーンでは、他の準備メカニズムがあるかもしれません。

それが終わると、イングレスポストと外部トランザクション（または外部データが表すもの）は、チェーンの仕様に従ってバランスを取りながら実行されます。(賢明なデフォルトは、外部トランザクションが処理される前に、すべてのイングレスポストの処理を要求することかもしれないが、これはパラシェーンのロジックが決定すべきことである)。この実行により、一連のegressポストが作成され、これらが本当に照合者の候補と一致するかどうかが検証される。最後に、適切に入力されたヘッダーが、候補者のヘッダーと照合されます。

候補ブロックが完全に検証されると、バリデータはそのヘッダのハッシュを投票し、 必要な検証情報をすべてそのサブグループの共同バリデータに送信することができる。